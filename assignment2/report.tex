\documentclass[a4wide,12pt]{article}
\usepackage{a4wide}
\usepackage{times}
\usepackage{fancyvrb}
\usepackage{url}
\usepackage{enumerate}
\usepackage{palatino}
\usepackage{rotating}
 
%\usepackage{prooftree}

\usepackage{amsmath, amsthm, amssymb}

\theoremstyle{definition}
\newtheorem{defi}{Definition}
\newtheorem{example}{Example}
\newtheorem*{conj}{Conjecture}
\newtheorem*{prob}{Problem}
\newtheorem*{question}{Question}
\theoremstyle{plain}
\newtheorem{theo}{Theorem}
\newtheorem{prop}[theo]{Proposition}
\newtheorem{lemma}[theo]{Lemma}
\newtheorem{cor}[theo]{Corolary}
\newtheorem*{theo*}{Theorem}
\newtheorem*{prop*}{Proposition}
\newtheorem*{lemma*}{Lemma}
\newtheorem*{cor*}{Corolary}
\theoremstyle{remark}
\newtheorem*{remark}{Remark}
\newtheorem*{notation}{Notation}
\def\qed{\begin{flushright} $\Box$ \end{flushright}}

\newenvironment{prf}
                {\vspace{-2mm} \noindent {\bf Proof.}}
                {\par \nopagebreak \qed }
\newenvironment{namedprf}[1]
                {\noindent {\bf Proof (#1).}}
                {\par \nopagebreak \qed }


\def\logequiv{\Leftrightarrow}

\allowdisplaybreaks[0]
 
\def\eq{\;\; = \;\;}
\def\N{\mathbb{N}}
\def\Z{\mathbb{Z}}
 
\def\pset#1{\mathcal{P}(#1)}
\def\A#1{\mathcal{A}[\hspace{-1pt}[#1]\hspace{-1pt}])}
 
\def\const#1{\mathopen{\langle}#1\mathclose{\rangle}} % <a,b,...z>
\def\pair#1{\const{#1}}
 
\def\Stmt {\mathbf{Stmt}}
\def\Lab {\mathbf{Lab}}
\def\Blocks{\mathbf{Blocks}}
\def\Var {\mathbf{Var}}
 
 
\def\skip {\texttt{skip}\ }
\def\whilel{\texttt{while}\ }
\def\dol {\texttt{do}\ }
\def\ifl {\texttt{if}\ }
\def\thenl {\texttt{then}\ }
\def\elsel {\texttt{else}\ }
\def\printl{\texttt{print}\ }
\def\contl {\texttt{continue}\ }
\def\breakl{\texttt{break}\ }
 
\def\haskell{\textsc{Haskell}}
 
\newcounter{Progenvcount}
\setcounter{Progenvcount}{0}
\newenvironment{progenv}
                {\refstepcounter{Progenvcount} \nopagebreak
                 \bigskip\hrule\nopagebreak\medskip\noindent
                 {\bf Program \arabic{Progenvcount}.} \nopagebreak\vspace{0.3cm} \nopagebreak \\ \nopagebreak
                  \nopagebreak
                 $\begin{array}{ll}}
                {\end{array}$ \bigskip\hrule\bigskip\bigskip }


%\def\programold#1{\fbox{\begin{minipage}{0.5\textwidth}\protect{$\begin{array}{ll} #1 \end{array}$}\end{minipage}}}

\def\restabR#1#2[#3]{
\begin{table}
{\scriptsize
\caption{#1}\label{#3}
\begin{center}\begin{sideways}\input{#2}\end{sideways}\end{center}
}
\end{table}}

\def\restabRtiny#1#2[#3]{
\begin{table}
{\tiny
\caption{#1}\label{#3}
\begin{center}\begin{sideways}\input{#2}\end{sideways}\end{center}
}
\end{table}}


\def\restab#1#2[#3]{
\begin{table}
\caption{#1}\label{#3}
\begin{center}\input{#2}\end{center}
\end{table}}


\def\program#1[#2]{\begin{progenv}\label{#2}\input{#1}\end{progenv}}

\def\Tiny{\fontsize{3pt}{3pt}\selectfont}
\def\hs#1{\texttt{#1}}

\def\rdsub{RD^\subseteq(S_\star)}

 
\begin{document}
\author{Chris Eidhof, Rui S. Barbosa}
\title{Data Flow Assignment II \\ Automatic Program Analysis}
 
\maketitle

\section{~}

We extend our lattice to take the context into account
\begin{align}
\hat{L} & = \Delta \to L
\end{align}

We start by lifting the regular transfer function $f_l$ to $\hat{f_l}$ just
like in the book (todo ref):

\begin{align}
\hat{f_l} & : \hat{L} \to \hat {L}
\hat{f_l} (\hat{l}) = f_l \circ \hat{l}
\end{align}

Now we still need to give the cases for \texttt{proc} and \texttt{call}. For
\texttt{proc} we give two transfer functions:

\texttt{proc p (val x, res y) is$^{l_n}$ S end$^{l_x}$}

Both $f_{l_n}$ and $f_{l_x}$ are the identity function. All the hard work is
done in the procedure calls:

Given $\{l_c, l_n, l_x, l_r\} \subset IF$ and a call with a corresponding
procedure:

\begin{align}
\texttt{[call p (a, z)]$^{l_c}_{l_r}$}\\
\texttt{proc p (val x, res y) is$^{l_n}$ S end$^{l_x}$}
\end{align}

\section{Lemma 2.15}

Our variant of Lemma 2.15 reads: Consider a label consistent program $S_\star$.
If $reach \models RD^=(S_\star)$ then $reach \models \rdsub$. The
least solution of $RD^=(S_\star)$ coincides with the least solution of $\rdsub$.

Proof: todo

\section{Lemma 2.16}

If we would substitute $RD$ for $LV$ and $reach$ for $live$, we end up with the
following variant of Lemma 2.16:

If $reach \models RD^\subseteq(S_1)$ (with $S_1$ being label consistent) and
$flow(S_1) \supseteq flow(S_2)$ and $blocks(S_1) \supseteq blocks(S_2)$ then
$reach \models RD^\subseteq(S_2)$ (with $S_2$ being label consistent).

However, in our case, this does not hold.  Because the $RD_{entry}(l)$ function
creates a $(x, ?)$ entry for every $x \in FV(S_\star)$, it might be the case
that $FV(S_2) \subset FV(S_1)$ which gives us a problem when we take a look at
the definition of the relation $\sim$:

\begin{align}
tr \sim Y \text{\ \ iff\ \ } \forall x \in DOM(tr): (x, SRD(tr)(x)) \in Y
\end{align}

It is straightforward to see that if $S_1$ contains a variable $x$ that $S_2$ does
not contain the domain of $reach$ will stay the same but there will not be an
entry for $x$ in $Y$. Therefore, we TODO

\section{Corollary 2.18}

We now present a variant of Corollary 2.18 for reaching definitions.

If $reach \models RD^\subseteq(S)$ (for $S$ being label consistent) and
if $\pair{S,\sigma} \to \pair{S', \sigma'}$ then also $reach \models RD^\subseteq(S')$.

\section{~}
 
\begin{align}
f^1_{l_r} (v) & = (v \setminus \{x, z\}) \cup (y \mid z \in v) \\
f^2_{l_r, l_c} (v, w) & = (w \setminus \{x, y\}) \cup FV(a) \cup (v \cap \{x, y\})
\end{align}

This means that 

\begin{align}
\widehat{f^1_{l_r}} (\hat{l}) (\delta) & = \bigsqcup \{ f^1_{l_r} (\hat{l}(\delta') \mid \delta = l_r :_k \delta' \}\\
\widehat{f^2_{l_r, l_c}} (\hat{l'}, \hat{l}) (\delta) & = f^2_{l_r, l_c} (\hat{l'}(\delta), \hat{l}(l_r :_k \delta))
\end{align}


\section{~}

\[reach_{entry}, reach_{exit} : \Lab_\star \to \pset{\Var_\star \times (\Lab_star \cup \{?\})}\]
\[reach \models RD^{\subset}(S)\]

In what follows, $N$ will stand for $reach_{entry}$ and $X$ for $reach_{exit}$. 


\begin{theo}
Let $S$ be a label consistent program and $reach \models RD^{\subset}(S)$. Then:
\begin{enumerate}
\item If $\pair{S,\sigma, tr} \to \pair{S', \sigma', tr'}$ and $tr \sim N(init(S))$, then $tr' \sim N(init(S'))$
\item If $\pair{S,\sigma, tr} \to \pair{\sigma', tr'}$ and $tr \sim N(init(S))$, then $tr' \sim X(init(S))$
\end{enumerate}
\end{theo}
\begin{proof}
The proof of this theorem goes by induction on the tree used to establish
the transition (computation step) according to the rules of the instrumented operational semantics.

Case $[ass]$:

We have $\pair{[x := a]^\ell, \sigma, tr} \to \pair{\sigma[x\mapsto\A{a}\sigma], tr:(x,l)}$
and $tr \sim N(\ell)$. 


From the constraints,


\[X(\ell) \supseteq (N(\ell) \setminus \{(x,l')|l' \in \Lab_\star^?\}) \cup \{(x,l)\}\]




Case $[skip]$:

We have $\pair{[\skip]^\ell, \sigma, tr} \to \pair{\sigma, tr}$
and $tr \sim N(\ell)$. 
From the constraints we have
\[X(\ell) \supseteq (N(\ell) \setminus \emptyset) \cup \emptyset = N(\ell)\]
Hence, by \ref{lemmasq}, $tr \sim X(\ell)$.

Case $[seq1]$:

We have $\pair{S_1;S_2,\sigma,tr} \to \pair{S'_1;S_2,\sigma',tr'}$ and $tr \sim N(init(S_1;S_2))$.
For the rule to apply, we also have $\pair{S_1,\sigma,tr} \to \pair{S'_1,\sigma',tr'}$.
As $S_1$ is a subprogram of $S_1;S_2$, by Lemma \ref{lemmasubp},
we can say that $reach \models RD^{\subset}(S_1)$. Also, $init(S_1;S_2) = init(S_1)$, so we have
$tr \sim N(S_1)$ and we can then apply the induction hypothesis, giving $tr' \sim  N(init(S'_1))$.
As $init(S'_1) = init(S'_1;S_2)$, we conclue $tr' \sim N(init(S'_1;S_2))$ as required.

Case $[seq2]$:

We have $\pair{S_1;S_2,\sigma,tr} \to \pair{S_2,\sigma',tr'}$ and $tr \sim N(init(S_1;S_2))$.
The antecedent of the rule is $\pair{S_1,\sigma,tr} \to \pair{\sigma',tr'}$.
By the same reason as in the previous case, we can apply the induction hypothesis, obtaining
$tr \sim X(init(S_1))$. By definition of flow, $\forall l. l \in final(S_1). \;(l,init(S_2) \in flow(S_1,S_2)$
By Lemma 2.14 from the book, $final(S_1) = \{init(S_1\}$ (because computation ended in one step). Thus,
$(init(S_1),init(S_1)) \in flow(S)$ and Lemma \ref{lemmaflow} gives $tr \sim N(init(S_2))$.

Case $[if1]$:

We have $\pair{\ifl [b]^\ell \thenl S_1 \elsel S_2,\sigma,tr} \to \pair{S1,\sigma,tr}$ and $tr \sim N(\ell)$.
From the constraints in $RD^{\subset}$, 
\[ X(\ell) \supset (N(\ell) \setminus \emptyset) \cup \emptyset = N(\ell)\]
Thus, by \ref{lemmasq}, $tr \sim X(\ell)$. Now, since $(l,init(S1)) \in flow(S)$, we can use Lemma \ref{lemmaflow}
to conclude $tr \sim N(init(S1))$.

Case $[if2]$:

The proof is the same as in the previous case, exchanging $S_1$ and $S_2$.

Case $[wh1]$:

We have $\pair{\whilel [b]^\ell \dol S_b,\sigma,tr} \to \pair{S_b;\whilel [b]^\ell \dol S_b,\sigma,tr}$ and $tr \sim N(\ell)$.
Again, from the constraints, we have
\[X(\ell) \supset (N(\ell) \setminus \emptyset) \cup \emptyset = N(\ell)\]
As before, $(l,init(S_b)) \in flow(S)$. Hence, as in the previous case, Lemmas \ref{lemmasq} and \ref{lemmaflow} give
$tr \sim N(init(S_b))$.

Case $[wh2]$:

We have $\pair{\whilel [b]^\ell \dol S_b,\sigma,tr} \to \pair{\sigma,tr}$ and $tr \sim N(\ell)$.
The constraints give
\[X(\ell) \supset (N(\ell) \setminus \emptyset) \cup \emptyset = N(\ell)\]
Thus, by Lemma \ref{lemmasq}, $tr \sim X(\ell)$.

\end{proof}
 
 
\end{document}
 
  
