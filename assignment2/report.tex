\documentclass[a4wide,12pt]{article}
\usepackage{a4wide}
\usepackage{times}
\usepackage{fancyvrb}
\usepackage{url}
\usepackage{enumerate}
\usepackage{palatino}
\usepackage{rotating}
 
%\usepackage{prooftree}

\usepackage{amsmath, amsthm, amssymb}

\theoremstyle{definition}
\newtheorem{defi}{Definition}
\newtheorem{example}{Example}
\newtheorem*{conj}{Conjecture}
\newtheorem*{prob}{Problem}
\newtheorem*{question}{Question}
\theoremstyle{plain} 
\newtheorem{theo}{Theorem}
\newtheorem{prop}[theo]{Proposition}
\newtheorem{lemma}[theo]{Lemma}
\newtheorem{cor}[theo]{Corollary}
\newtheorem*{theo*}{Theorem}
\newtheorem*{prop*}{Proposition}
\newtheorem*{lemma*}{Lemma}
\newtheorem*{cor*}{Corollary}
\theoremstyle{remark}
\newtheorem*{remark}{Remark}
\newtheorem*{notation}{Notation}
\def\qed{\begin{flushright} $\Box$ \end{flushright}}

\newenvironment{prf}
                {\vspace{-2mm} \noindent {\bf Proof.}}
                {\par \nopagebreak \qed }
\newenvironment{namedprf}[1]
                {\noindent {\bf Proof (#1).}}
                {\par \nopagebreak \qed }


\def\logequiv{\Leftrightarrow}

\allowdisplaybreaks[0]
 
\def\eq{\;\; = \;\;}
\def\N{\mathbb{N}}
\def\Z{\mathbb{Z}}
 
\def\pset#1{\mathcal{P}(#1)}
\def\A#1{\mathcal{A}[\hspace{-1pt}[#1]\hspace{-1pt}]}
 
\def\const#1{\mathopen{\langle}#1\mathclose{\rangle}} % <a,b,...z>
\def\pair#1{\const{#1}}
 
\def\Stmt {\mathbf{Stmt}}
\def\Lab {\mathbf{Lab}}
\def\Blocks{\mathbf{Blocks}}
\def\Var {\mathbf{Var}}
 
 
\def\skip {\texttt{skip}\ }
\def\whilel{\texttt{while}\ }
\def\dol {\texttt{do}\ }
\def\ifl {\texttt{if}\ }
\def\thenl {\texttt{then}\ }
\def\elsel {\texttt{else}\ }
\def\printl{\texttt{print}\ }
\def\contl {\texttt{continue}\ }
\def\breakl{\texttt{break}\ }
 
\def\haskell{\textsc{Haskell}}
\def\starto{\overset{\star}{\to}}
 
\newcounter{Progenvcount}
\setcounter{Progenvcount}{0}
\newenvironment{progenv}
                {\refstepcounter{Progenvcount} \nopagebreak
                 \bigskip\hrule\nopagebreak\medskip\noindent
                 {\bf Program \arabic{Progenvcount}.} \nopagebreak\vspace{0.3cm} \nopagebreak \\ \nopagebreak
                  \nopagebreak
                 $\begin{array}{ll}}
                {\end{array}$ \bigskip\hrule\bigskip\bigskip }


%\def\programold#1{\fbox{\begin{minipage}{0.5\textwidth}\protect{$\begin{array}{ll} #1 \end{array}$}\end{minipage}}}

\def\restabR#1#2[#3]{
\begin{table}
{\scriptsize
\caption{#1}\label{#3}
\begin{center}\begin{sideways}\input{#2}\end{sideways}\end{center}
}
\end{table}}

\def\restabRtiny#1#2[#3]{
\begin{table}
{\tiny
\caption{#1}\label{#3}
\begin{center}\begin{sideways}\input{#2}\end{sideways}\end{center}
}
\end{table}}


\def\restab#1#2[#3]{
\begin{table}
\caption{#1}\label{#3}
\begin{center}\input{#2}\end{center}
\end{table}}


\def\program#1[#2]{\begin{progenv}\label{#2}\input{#1}\end{progenv}}

\def\Tiny{\fontsize{3pt}{3pt}\selectfont}
\def\hs#1{\texttt{#1}}

\def\rdsub{RD^\subseteq(S_\star)}

 
\begin{document}
\author{Chris Eidhof, Rui S. Barbosa}
\title{Data Flow Assignment II \\ Automatic Program Analysis}
 
\maketitle

Our goal is to prove the correctness of reaching definitions analysis.
We follow the structure of the proof presented in the book for the LV analysis.

We start by presenting the analysis itself: the constraints generated for each program. Here,
we make a deviation from the book, dropping the initial undefinedness constraints. For that
modified analysis, we prove results analogous to the propositions 2.16 to 2.21 in the book.
Then, we reintroduce the undefinedness constraints into our analysis and prove the corresponding
correctness result. In the end, we consider the relationship (analogous to Lemma 2.15)
between the analysis using equations and
the corresponding analysis using constraints (which we used for the proof).

\section{The Analysis}

As we said, from here onwards we will consider $\iota$ to be the empty set. In our final result, we
will show how our solution can be adapted for a non-empty $\iota$ that introduces
undefinedness in the beginning.

Thus, the set $RD^\subseteq(S)$ of constraints generated for a program $S$ is:

\begin{align} 
\label{def_constr}
RD^{\subseteq}(S) = & \; \{RD_{exit}(\ell) \supseteq RD_{entry}(\ell) \setminus kill_{RD}(B^l)) \cup gen_{RD}(B^l) \mid B^l \in blocks(S)\} \\
\cup & \; \{RD_{entry}(\ell) \supseteq RD_{exit}(\ell') \mid (\ell', \ell) \in flow(S) \}
\end{align}

A solution, $reach$, to the constraint system $RD^\subseteq(S)$ is a pair of functions
\[reach_{entry}, reach_{exit} : \Lab_\star \to \pset{\Var_\star \times (\Lab_star \cup \{?\})}\] 
that satisfies the constraints (when instantiating $RD_entry$/$RD_{exit}$ with $reach_{entry}$/$reach_{exit}$.
In that case, we write
\[reach \models RD^{\subseteq}(S)\]

In what follows, $N$ will stand for $reach_{entry}$ and $X$ for $reach_{exit}$. 


Note that we presented only a constraint system (as opposed to a equation based system 
as in the analysis formulation). In fact, just as for the case of Live Variables Analysis,
the correctness proof is much simpler to conduct using constraints. Anyway,
the correctness for $RD^\subseteq$ implies the correctness for the corresponding
equation based system. We defer the proof of a result similar to that of Lemma 2.15 in the book
until the end of this section, after we have reintroduced the undefinedness constraints.


\subsection*{Lemmas about the Analysis (cf. 2.16,2.18)}

We present two lemmas about solution $reach$ to the constraints, which are variants
of lemmas 2.16 and 2.18 in the book for reaching definitions analysis.

The former 
shows that a solution for a program is also a solution for the constraints of any
subprogram, so that, in a certain sense, constraints generation is composed incrementally.
This result will be essential to prove the main theorem, particularly the cases when
to semantic rules have non-empty premisses. 
It is worth noticing that this property would not hold if we took $\iota \neq \emptyset$.

\begin{lemma}[Subprogram Solutions (cf Lemma 2.16)]
If $reach \models RD^\subseteq(S_1)$ (with $S_1$ being label consistent) and
$flow(S_1) \supseteq flow(S_2)$ and $blocks(S_1) \supseteq blocks(S_2)$ then
$reach \models RD^\subseteq(S_2)$ (with $S_2$ being label consistent).
\end{lemma}
\begin{proof}
We now have that $RD^{\supseteq}(S_1) \supseteq RD^{\supseteq}(S_2)$, so as
$reach \models RD^\subseteq(S_1)$ also $reach \models RD^\subseteq(S_2)$.
\end{proof}


The second result simply states that the analysis results are
propagated (forwardly) through the flow graph of the program.

\begin{lemma}[Solutions through Flow (cf. Lemma 2.18)]
\label{lem218}
If $reach \models RD^\subseteq(S)$ (for $S$ being label consistent) then for all
$(\ell, \ell') \in flow(S)$ we have $reach_{entry}(\ell') \supseteq reach_{exit}(\ell)$.
\end{lemma}
\begin{proof}
Because of the definition of $RD^\subseteq$ and \ref{def_constr} this follows
immediately.
(REWRITE, ref)
\end{proof}

\subsection*{Lemmas about the correctness relation (cf. 2.20) }

Now, we consider some simple properties about the correctness relation.

SHOULD WE PRESENT THE DEF OF THE RELATION HERE?

EXPLAIN NEXT LEMMA

\begin{lemma}
\label{lemmasq}
If $tr \sim Y \and Y \subseteq Y'$ then $tr \sim Y'$.
\end{lemma}
\begin{proof}
By definition of $\sim$
this follows immediately.
(ADD SMTHING HERE)
\end{proof}

EXPLAIN tHIS LEMMA

\begin{lemma}[Flow Preserves Correctness(cf. Lemma 2.20)]\label{lemmaflow}
Assume $reach \models RD^\subseteq(S)$ with $S$ being label consistent. Then,
$tr \sim X(\ell)$ implies $tr \sim N(\ell')$ for all $(\ell, \ell')$ in $flow(S)$.
\end{lemma}
\begin{proof}
By \ref{lem218}, $X(\ell) \subseteq N(\ell')$. We then apply \ref{lemmasq}.
\end{proof}


\subsection*{Correctness Result (cf. 2.21)}

BRIEF EXPLANATION

\begin{theo}[Stepwise Correctness (cf. Theorem 2.21)]
\label{theo221}
Let $S$ be a label consistent program and $reach \models RD^{\subseteq}(S)$. Then:
\begin{enumerate}
\item If $\pair{S,\sigma, tr} \to \pair{S', \sigma', tr'}$ and $tr \sim N(init(S))$, then $tr' \sim N(init(S'))$
\item If $\pair{S,\sigma, tr} \to \pair{\sigma', tr'}$ and $tr \sim N(init(S))$, then $tr' \sim X(init(S))$
\end{enumerate}
\end{theo}
\begin{proof}
The proof of this theorem goes by induction on the tree used to establish
the transition (computation step) according to the rules of the instrumented operational semantics.

Case $[ass]$:

We have $\pair{[x := a]^\ell, \sigma, tr} \to \pair{\sigma[x\mapsto\A{a}\sigma], tr:(x,l)}$
and $tr \sim N(\ell)$. 


From the constraints,

\begin{equation}\label{assconst}
X(\ell) \supseteq (N(\ell) \setminus \{(x,\ell') \mid \ell' \in \Lab_\star^?\}) \cup \{(x,l)\}
\end{equation}

Our goal is to prove that $tr' \sim X(init(S))$, that is to say $(tr:(x,l)) \sim X(\ell)$.
Looking at the definition of $\sim$,
this amounts to prove that $(y,SRD(tr')(y)) \in X(\ell)$ for every $y \in DOM(tr')$.

The case $y=x$ is straightforward, as
we then have \[(y,SRD(tr')(y)) = (x,SRD(tr:(x,\ell))(x)) = (x,l)\] which can easily be seen to be in $X(\ell)$, from \ref{assconst}.

As for $y\neq x$, we just have \[(y,SRD(tr')(y)) = (y,SRD(tr:(x,l))(y)) = (y,SRD(tr)(y))\] which clearly is in $N(\ell)$ (because $y \in DOM(tr)$ and $tr \sim N(\ell)$).
Because $y\neq x$, then it is also in $N(\ell) \setminus \{(x,\ell') \mid \ell' \in \Lab_\star^?\}$, which in turn is contained in $X(\ell)$, by equation \ref{assconst}.


Case $[skip]$:

We have $\pair{[\skip]^\ell, \sigma, tr} \to \pair{\sigma, tr}$
and $tr \sim N(\ell)$. 
From the constraints we have
\[X(\ell) \supseteq (N(\ell) \setminus \emptyset) \cup \emptyset = N(\ell)\]
Hence, by Lemma \ref{lemmasq}, $tr \sim X(\ell)$.

Case $[seq1]$:

We have $\pair{S_1;S_2,\sigma,tr} \to \pair{S'_1;S_2,\sigma',tr'}$ and $tr \sim N(init(S_1;S_2))$.
For the rule to apply, we also have $\pair{S_1,\sigma,tr} \to \pair{S'_1,\sigma',tr'}$.
As $S_1$ is a subprogram of $S_1;S_2$, by Lemma \ref{lemmasubp},
we can say that $reach \models RD^{\subseteq}(S_1)$. Also, $init(S_1;S_2) = init(S_1)$, so we have
$tr \sim N(S_1)$ and we can then apply the induction hypothesis, giving $tr' \sim  N(init(S'_1))$.
As $init(S'_1) = init(S'_1;S_2)$, we conclude $tr' \sim N(init(S'_1;S_2))$ as required.

Case $[seq2]$:

We have $\pair{S_1;S_2,\sigma,tr} \to \pair{S_2,\sigma',tr'}$ and $tr \sim N(init(S_1;S_2))$.
The antecedent of the rule is $\pair{S_1,\sigma,tr} \to \pair{\sigma',tr'}$.
By the same reason as in the previous case, we can apply the induction hypothesis, obtaining
$tr' \sim X(init(S_1))$. By definition of flow, \[\forall \ell . \; \ell \in final(S_1). \;(\ell,init(S_2)) \in flow(S_1;S_2)\]
By Lemma 2.14 from the book, $final(S_1) = \{init(S_1)\}$ (because computation ended in one step). Thus,
$(init(S_1),init(S_2)) \in flow(S)$ and Lemma \ref{lemmaflow} gives $tr \sim N(init(S_2))$.

Case $[if1]$:

We have $\pair{\ifl [b]^\ell \thenl S_1 \elsel S_2,\sigma,tr} \to \pair{S1,\sigma,tr}$ and $tr \sim N(\ell)$.
From the constraints in $RD^{\subseteq}$, 
\[ X(\ell) \supset (N(\ell) \setminus \emptyset) \cup \emptyset = N(\ell)\]
Thus, by \ref{lemmasq}, $tr \sim X(\ell)$. Now, since $(\ell,init(S1)) \in flow(S)$, we can use Lemma \ref{lemmaflow}
to conclude $tr \sim N(init(S1))$.

Case $[if2]$:

The proof is the same as in the previous case, exchanging $S_1$ and $S_2$.

Case $[wh1]$:

We have $\pair{\whilel [b]^\ell \dol S_b,\sigma,tr} \to \pair{S_b;\whilel [b]^\ell \dol S_b,\sigma,tr}$ and $tr \sim N(\ell)$.
Again, from the constraints, we have
\[X(\ell) \supset (N(\ell) \setminus \emptyset) \cup \emptyset = N(\ell)\]
As before, $(\ell,init(S_b)) \in flow(S)$. Hence, as in the previous case, Lemmas \ref{lemmasq} and \ref{lemmaflow} give
$tr \sim N(init(S_b))$.

Case $[wh2]$:

We have $\pair{\whilel [b]^\ell \dol S_b,\sigma,tr} \to \pair{\sigma,tr}$ and $tr \sim N(\ell)$.
The constraints give
\[X(\ell) \supset (N(\ell) \setminus \emptyset) \cup \emptyset = N(\ell)\]
Thus, by Lemma \ref{lemmasq}, $tr \sim X(\ell)$.

\end{proof}


\begin{cor}[Through-Execution Correctness (cf. Corollary 2.22)]
If $reach \models RD^\subseteq(S)$ (with $S$ being label consistent) then:


\begin{enumerate}
\item If $\pair{S, \sigma, tr} \starto \pair{S', \sigma', tr'}$ and $ tr \sim
N(init(S))$ then $tr' \sim N(init(S'))$
\item If $\pair{S, \sigma, tr} \starto \pair{\sigma', tr'}$ and $ tr \sim
N(init(S))$ then $tr' \sim X(\ell)$ for some $\ell \in final(S)$.
\end{enumerate}
\end{cor}
\begin{proof}
This proof is by induction on the length of the derivation sequence and uses
\ref{theo221} at each step.
\end{proof}

\subsection*{title}

REVIEW THIS TEXT

Informally, the above result means that execution of a piece of code keeps the analysis results correct with respect to the semantics.
That is, if we have $reach \models RD^\subseteq(S)$ and we have a correct analysis result for $reach_{entry}(init(S))$, then the analysis results will
be correct with respect to every possible path at all (reachable) program points. 
This is exactly what one would expect from a solution to $RD^\subseteq(S)$. 

We now consider the whole $RD$ analysis:
for a program $S_\star$, we generate all the constraints in $RD^\subseteq(S_\star)$ plus a constraint
introducing variable undefinedness at the beginning. 
 
\[RD^\subseteq_\star(S_\star) = RD^\subseteq(S_\star) \cup \{ \{(x,?) \mid x \in \Var_\star\} \subseteq init(S_\star) \}\]

This set of constraints is intended to be applied only once, for the ``full'' program.
The idea is that it correctly captures the semantics of executions of complete programs
(but not of subprograms where some code has already been executed, unless we wanted to ``forget''
this code).

In the semantics side, a full evaluation of $S_\star$ starts from $\pair{S_\star,\sigma,tr_0}$
where $\sigma$ is some initial state and $tr_0$ is the trace at the beginning, where yet no code
has been executed.
\[tr_0 = [ (x,?) \mid x \in Var_\star(S_\star) ] \]

With these definitions, we can then formulate our correctness result.
\begin{theo}[Correctness of $RD^\subseteq_\star$]
If $reach \models RD_\star^\subseteq(S_\star)$ (with $S_\star$ being label consistent) then:

\begin{enumerate}
\item If $\pair{S_\star, \sigma, tr_0} \starto \pair{S', \sigma', tr'}$ then $ tr' \sim
N(init(S'))$ 
\item If $\pair{S_\star, \sigma, tr_0} \starto \pair{\sigma', tr'}$ then $ tr' \sim
X(\ell)$ for some $\ell \in final(S_\star)$.
\end{enumerate}
\end{theo}
\begin{proof}
REWRITE ``PROOF''
 
The proof is straightforward: basically the old constraints guarantee that the results are correctly propagated to each (reachable)
program point (as seen in \ref{corr}) while the new constraint give us correct results to start with.
\end{proof}

 
\subsection*{Equation-Based Analysis}

DEFINE $RD^=(S)$.


\begin{lemma}[Relationship between $RD_\star^\subseteq$ and $RD_\star^=$]
Consider a label consistent program $S_\star$.  If $reach \models RD_\star^=(S_\star)$
then $reach \models RD_\star^\subseteq$. The least solution of $RD_\star^=(S_\star)$ coincides
with the least solution of $RD_\star^\subseteq$.
\end{lemma}
\begin{proof}
If $reach \models RD_\star^=(S_\star)$
then clearly $reach \models \rdsub$ because $=$ is a subrelation of $\supseteq$.

Next we prove that $reach \models \rdsub$ has the same least solution
as  $reach \models RD_\star^=(S_\star)$. The proof is the same as in the book, but we
need to make sure our lattice is complete and our function $F_{RD_\star}^S$ is monotone.
For $F_{RD_\star}^S$ we can the function defined in section 1.3, and because of its
type, a product of power sets, it is a complete lattice.
\end{proof}


\section{~} 
%PART 2

\subsection{Title}

For our data flow equations, we use the definition in the book for $A$ as
described in section 2.5.3.

We extend our lattice to take the context into account
\begin{align}
\widehat{L} & = \Delta \to L = \Delta \to \pset{\Var_\star}
\end{align}

We start by lifting the regular transfer function $f_l$ to $\widehat{f_l}$ just
like in the book (todo ref):

\begin{align}
\widehat{f_l} & : \widehat{L} \to \widehat {L} \\
\widehat{f_l} (\widehat{l}) & = f_l \circ \widehat{l}
\end{align}

Now we still need to give the cases for \texttt{proc} and \texttt{call}. For
\texttt{proc} we give two transfer functions:

\texttt{proc p (val x, res y) is$^{\ell_n}$ S end$^{\ell_x}$}

Both $f_{\ell_n}$ and $f_{\ell_x}$ are the identity function. All the hard work is
done in the procedure calls:

Given $(\ell_c, \ell_n, \ell_x, \ell_r) \in IF$ and a call with a corresponding
procedure:

\begin{align}
\texttt{[call p (a, z)]$^{\ell_c}_{\ell_r}$}\\
\texttt{proc p (val x, res y) is$^{\ell_n}$ S end$^{\ell_x}$}
\end{align}

The intuition for our functions is that at the end of a procedure we are going
to have all live variables except for the parameters and we only make the result
live if it is actually used. Before the call we get $v$ and $w$, and we will
take out the parameters again, make sure we add every free variable in the
argument for the call and add $x$ and $y$ only if they were live before the call
(we have to compensate for the shadowing in the procedure).
 
\begin{align}
f^1_{\ell_r} (v) & = (v \setminus \{x, z\}) \cup \{y \mid z \in v\} \\
f^2_{\ell_r, \ell_c} (v, w) & = (w \setminus \{x, y\}) \cup FV(a) \cup (v \cap \{x, y\})
\end{align}

Now we are ready to give the context-sensitive functions for call strings with
unbounded length.

\begin{align}
\widehat{f^1_{\ell_r}} (\widehat{\ell}) (\delta) & = \bigsqcup \{ f^1_{\ell_r} (\widehat{\ell}(\delta') \mid \delta = \ell_r : \delta' \} \\
\widehat{f^2_{\ell_r, \ell_c}} (\widehat{\ell'}, \widehat{\ell}) (\delta) & = f^2_{\ell_r, \ell_c} (\widehat{\ell'}(\delta), \widehat{\ell}(\ell_r : \delta))
\end{align}

When doing call strings of bounded length $k$, we replace our $cons$-operator by
$:_k$ which is defined as following:

\begin{align}
x :_k xs = take\ k\ (x : xs)
\end{align}

Now we can use our previous definitions with $:$ replaced by $:_k$:

\begin{align}
\widehat{f^1_{\ell_r}} (\widehat{\ell}) (\delta) & = \bigsqcup \{ f^1_{\ell_r} (\widehat{\ell}(\delta') \mid \delta = \ell_r :_k \delta' \} \\
\widehat{f^2_{\ell_r, \ell_c}} (\widehat{\ell'}, \widehat{\ell}) (\delta) & = f^2_{\ell_r, \ell_c} (\widehat{\ell'}(\delta), \widehat{\ell}(\ell_r :_k \delta))
\end{align}

\subsection{Example}
We only give the $X$-values for the interesting cases (label 1 and 14).

\begin{table}
$
\begin{array}{lcccccccccccccccccccccccccccccccccccc}
\  & [11, 11] & [9, 11] & [7, 11] & [3] & [11, 3] & [9, 3] & [7, 3] & [11, 9] & [9, 9 & [7, 9] & [\,] \\
N(1)  & \emptyset & \emptyset & \emptyset & \emptyset & \emptyset & \emptyset & \emptyset & \emptyset & \emptyset & \emptyset & \{x\}     \\
X(1)  & \emptyset & \emptyset & \emptyset & \emptyset & \emptyset & \emptyset & \emptyset & \emptyset & \emptyset & \emptyset & \{x, y\}  \\
N(2)  & \emptyset & \emptyset & \emptyset & \emptyset & \emptyset & \emptyset & \emptyset & \emptyset & \emptyset & \emptyset & \{x, y\} \\
N(3)  & \emptyset & \emptyset & \emptyset & \emptyset & \emptyset & \emptyset & \emptyset & \emptyset & \emptyset & \emptyset & \emptyset \\
N(4)  & \{ z, y\}   & \{z, y\}   & \emptyset & \{z, y\}   & \{z, y\}   & \{z, y\}   & \emptyset & \{z, y\}   & \{z, y\}   & \emptyset & \emptyset \\
N(5)  & \{ z, y\}   & \{z, y\}   & \emptyset & \{z, y\}   & \{z, y\}   & \{z, y\}   & \emptyset & \{z, y\}   & \{z, y\}   & \emptyset & \emptyset \\ 
N(6)  & \{    y\}   & \{   y\}   & \emptyset & \{   y\}   & \{   y\}   & \{   y\}   & \emptyset & \{   y\}   & \{y   \}   & \emptyset & \emptyset \\
N(7)  & \{    y\}   & \{   y\}   & \emptyset & \emptyset & \emptyset &    y   & \emptyset &    y   & y      & \emptyset & \emptyset \\
N(8)  & \{ z, y\}   & \{z, y\}   & \emptyset & \{z, y\}   & \{z, y\}   & \{z, y\}   & \emptyset & \{z, y\}   & \{z, y\}   & \emptyset & \emptyset \\
N(9)  & \{ z, y\}   & \{z, y\}   & \emptyset & \{z, y\}   & \{z, y\}   & \{z, y\}   & \emptyset & \{z, y\}   & \{z, y\}   & \emptyset & \emptyset \\
N(10) & \{ z, y\}   & \{z, y\}   & \emptyset & \{z, y\}   & \{z, y\}   & \{z, y\}   & \emptyset & \{z, y\}   & \{z, y\}   & \emptyset & \emptyset \\
N(11) & \{    y\}   & \{   y\}   & \emptyset & \emptyset & \emptyset &    \{y\}   & \emptyset &    \{y\}   & \{y\}      & \emptyset & \emptyset \\
N(12) & \{    y\}   & \{   y\}   & \emptyset & \emptyset & \emptyset &    \{y\}   & \emptyset &    \{y\}   & \{y\}      & \emptyset & \emptyset \\
N(13) & \emptyset & \emptyset & \{y, u\}   & \emptyset & \emptyset & \emptyset & \{y, u\}   & \emptyset & \emptyset & \{y, u\}   & \emptyset \\
N(14) & \emptyset & \emptyset & \{y, u\}   & \emptyset & \emptyset & \emptyset & \{y, u\}   & \emptyset & \emptyset & \{y, u\}   & \emptyset \\
X(14) & \emptyset & \emptyset & \{y   \}  & \emptyset & \emptyset & \emptyset & \{y\}     & \emptyset & \emptyset & \{y\}     & \emptyset \\
N(15) & \emptyset & \emptyset & \{y   \}   & \emptyset & \emptyset & \emptyset & \emptyset & \emptyset & \emptyset & \{y\}      & \emptyset \\
N(16) & \emptyset & \emptyset & \{y   \}   & \emptyset & \emptyset & \emptyset & \emptyset & \emptyset & \emptyset & \{y\}      & \emptyset
\end{array}
$
\end{table}

\end{document}
 
  

