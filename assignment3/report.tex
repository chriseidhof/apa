\documentclass[a4wide,12pt]{article}
\usepackage{a4wide}
\usepackage{times}
\usepackage{fancyvrb}
\usepackage{url}
\usepackage{enumerate}
\usepackage{palatino}
\usepackage{rotating}
 
\usepackage{prooftree}

\usepackage{amsmath, amsthm, amssymb}

\theoremstyle{definition}
\newtheorem{defi}{Definition}
\newtheorem{example}{Example}
\newtheorem*{conj}{Conjecture}
\newtheorem*{prob}{Problem}
\newtheorem*{question}{Question}
\theoremstyle{plain} 
\newtheorem{theo}{Theorem}
\newtheorem{prop}[theo]{Proposition}
\newtheorem{lemma}[theo]{Lemma}
\newtheorem{cor}[theo]{Corollary}
\newtheorem*{theo*}{Theorem}
\newtheorem*{prop*}{Proposition}
\newtheorem*{lemma*}{Lemma}
\newtheorem*{cor*}{Corollary}
\theoremstyle{remark}
\newtheorem*{remark}{Remark}
\newtheorem*{notation}{Notation}
\def\qed{\begin{flushright} $\Box$ \end{flushright}}

\newenvironment{prf}
                {\vspace{-2mm} \noindent {\bf Proof.}}
                {\par \nopagebreak \qed }
\newenvironment{namedprf}[1]
                {\noindent {\bf Proof (#1).}}
                {\par \nopagebreak \qed }


\def\logequiv{\Leftrightarrow}

\allowdisplaybreaks[0]
 
\def\eq{\;\; = \;\;}
\def\N{\mathbb{N}}
\def\Z{\mathbb{Z}}
 
\def\pset#1{\mathcal{P}(#1)}
\def\A#1{\mathcal{A}[\hspace{-1pt}[#1]\hspace{-1pt}]}
 
\def\const#1{\mathopen{\langle}#1\mathclose{\rangle}} % <a,b,...z>
\def\pair#1{\const{#1}}
 
\def\Stmt {\mathbf{Stmt}}
\def\Lab {\mathbf{Lab}}
\def\Blocks{\mathbf{Blocks}}
\def\Var {\mathbf{Var}}
\def\Type {\mathbf{Type}}
\def\AType{\mathbf{AType}}
\def\Annot{\mathbf{Annot}}
\def\ATypeScheme{\mathbf{ATypeScheme}}

 
 
\def\skip {\texttt{skip}\ }
\def\whilel{\texttt{while}\ }
\def\dol {\texttt{do}\ }
\def\ifl {\texttt{if}\ }
\def\thenl {\texttt{then}\ }
\def\elsel {\texttt{else}\ }
\def\printl{\texttt{print}\ }
\def\contl {\texttt{continue}\ }
\def\breakl{\texttt{break}\ }
 
\def\haskell{\textsc{Haskell}}
\def\starto{\overset{\star}{\to}}
 
\newcounter{Progenvcount}
\setcounter{Progenvcount}{0}
\newenvironment{progenv}
                {\refstepcounter{Progenvcount} \nopagebreak
                 \bigskip\hrule\nopagebreak\medskip\noindent
                 {\bf Program \arabic{Progenvcount}.} \nopagebreak\vspace{0.3cm} \nopagebreak \\ \nopagebreak
                  \nopagebreak
                 $\begin{array}{ll}}
                {\end{array}$ \bigskip\hrule\bigskip\bigskip }


%\def\programold#1{\fbox{\begin{minipage}{0.5\textwidth}\protect{$\begin{array}{ll} #1 \end{array}$}\end{minipage}}}

\def\restabR#1#2[#3]{
\begin{table}
{\scriptsize
\caption{#1}\label{#3}
\begin{center}\begin{sideways}\input{#2}\end{sideways}\end{center}
}
\end{table}}

\def\restabRtiny#1#2[#3]{
\begin{table}
{\tiny
\caption{#1}\label{#3}
\begin{center}\begin{sideways}\input{#2}\end{sideways}\end{center}
}
\end{table}}


\def\restab#1#2[#3]{
\begin{table}
\caption{#1}\label{#3}
\begin{center}\input{#2}\end{center}
\end{table}}

\def\sqleq{\sqsubseteq}

\def\htau{\hat{\tau}}
\def\hsigma{\hat{\sigma}}
\def\HGamma{\hat{\Gamma}}
\def\judge#1#2#3{#1 \vdash #2 : #3\;\;}

\def\annot#1{\|#1\|}
\def\baset#1{\lfloor#1\rfloor}

\def\program#1[#2]{\begin{progenv}\label{#2}\input{#1}\end{progenv}}

\def\Tiny{\fontsize{3pt}{3pt}\selectfont}
\def\hs#1{\texttt{#1}}

\begin{document}
\author{Chris Eidhof, Rui S. Barbosa}
\title{Type and Effect Systems Assignment \\ Automatic Program Analysis}
 
\maketitle

TODO: main rule for the 3 analysis

\section{Monovariant Binding Time Analysis}

\subsection{Types and Annotations}
As in the book, we have the base type system $\Type$ where $\tau \in \Type$ are given by:
\[\tau := bool \mid int \mid \tau_1 \to \tau_2\]

We  now add annotations to our types. These annotations are always
one of the two values $S$ (for static) and $D$ (for Dynamic). 
We need such an annotation
at all levels in a type (and not only in functions). We designate the set of annotations by $\Annot$ and
the set of annotated types by
$\AType$. $\htau \in \AType$ and $\varphi \in \Annot$ are given by:
\begin{align*}
\htau  \; := \; & bool^\varphi \mid int^\varphi \mid \htau_1 \overset{\varphi}{\to} \htau_2 \\
& \\
\varphi \; := \; & S \mid D\\
\end{align*}

$\Annot$ is endowed with a lattice structure where $S$ is bottom and  $D$ is top. We write $\sqleq$ for
the associated order relation. 

Given an annotated type $\htau$, $\annot{\htau}$ stands for its topmost annotation
and $\baset{\htau}$ stands for its underlying (not annotated) type. That is:
\begin{align*}
 \annot{.} : \AType &\to \Annot\\
 \annot{bool^\varphi} & = \varphi \\
 \annot{int^\varphi} & = \varphi \\
 \annot{\htau_1 \overset{\varphi}{\to} \htau_2} & = \varphi \\
\\
\baset{.}  : \AType &\to \Type\\
\baset{bool^\varphi} & = bool \\
\baset{int^\varphi} & = int \\
\baset{\htau_1 \overset{\varphi}{\to} \htau_2} & = \baset{\htau_1} \to \baset{\htau_2} \\
\end{align*}


Actually, some annotated types are not allowed, so we need to introduce a well-formedness
constraint to restrict them. Basically, this constraint will express that a dynamic function
has to map a dynamic argument to a dynamic result. So, it 
cannot receive static arguments and cannot produce static results. The latter is actually
an impossible situation, whilst the former will be considered again in the other versions
(dynamic functions will be able to accept static arguments, even though they still expect dynamic arguments,
thus the constraint will be kept).
We will just be concerned to give a definition of well-formedness at top level and
induction on the type rules then guarantees that only
well-formed types are ever constructed.
\[
wff(\htau_1 \overset{\varphi}{\to} \htau_2) 
= \varphi \sqleq \annot{\htau_1}
 \land   \varphi \sqleq \annot{\htau_2}
\]

\subsection{Type Rules}

We now present the type rules for monomorphic binding-time analysis.

The judgments are of the form
\[\judge{\HGamma}{e}{\htau}\]
where $\HGamma: Var_\star \to AType$ is the context, assigning types to each program variable, 
$e \in Stmt$ is an expression in the \textsc{Fun} language and $\htau \in AType$ is an annotated type.
The meaning is that we can assign the annotated type $\htau$ to expression $e$ under the context $\HGamma$. 

TODO: SOME EXPLANATION ON THE RULES

\begin{eqnarray*}
\lbrack con \rbrack\;\; &
\begin{prooftree}
\justifies
\judge{\HGamma}{c}{\tau_c^\varphi}
\end{prooftree}\\
& & \\
\lbrack var\rbrack\;\; &
\begin{prooftree}
\HGamma(x)=\htau
\justifies
\judge{\HGamma}{x}{\htau}
\end{prooftree}\\
& & \\
\lbrack fn \rbrack\;\; &
\begin{prooftree}
\judge{\HGamma[x\mapsto\htau_1]}{e}{\htau_2}
\justifies
\judge{\HGamma}{fn\; x \Rightarrow e}{\htau_1 \overset{\varphi}{\to} \htau_2}
\end{prooftree}\;\; \text{if}\;\;
\varphi \sqleq \annot{\htau_1} \land \varphi \sqleq \annot{\htau_2} \\
& & \\
\lbrack fun \rbrack\;\; &
\begin{prooftree}
\judge{\HGamma[f \mapsto \htau_1 \overset{\varphi}{\to} \htau_2][x\mapsto\htau_1]}{e}{\htau_2}
\justifies
\judge{\HGamma}{fun\; x \Rightarrow e}{\htau_1 \overset{\varphi}{\to} \htau_2}
\end{prooftree}\;\; \text{if}\;\;
\varphi \sqleq \annot{\htau_1} \land \varphi \sqleq \annot{\htau_2} \\
& & \\
\lbrack app \rbrack\;\; &
\begin{prooftree}
\judge{\HGamma}{e_1}{\htau_1 \overset{\varphi}{\to} \htau_2}\;  \judge{\HGamma}{e_2}{\htau_1}
\justifies
\judge{\HGamma}{e_1 \; e_2}{\htau_2}
\end{prooftree}\\
& & \\
\lbrack if \rbrack\;\; &
\begin{prooftree}
\judge{\HGamma}{e_0}{bool^{\varphi_0}}
\judge{\HGamma}{e_1}{\htau}
\judge{\HGamma}{e_2}{\htau}
\justifies
\judge{\HGamma}{if\;e_0\;then\;e_1\;else\;e_2}{\htau}
\end{prooftree}\;\;\text{if}\;\;
\varphi_0 \sqleq \annot{\htau}\\
& & \\
\lbrack let \rbrack\;\; &
\begin{prooftree}
\judge{\HGamma}{e_1}{\htau_1}
\judge{\HGamma[x \mapsto \htau_1]}{e_2}{\htau_2}
\justifies
\judge{\HGamma}{let\; x=e_1\; in\; e_2}{\htau_2}
\end{prooftree}\\
& & \\
\lbrack op \rbrack\;\; &
\begin{prooftree}
\judge{\HGamma}{e_1}{\tau_{op_1}^\varphi}
\judge{\HGamma}{e_2}{\tau_{op_2}^\varphi}
\justifies
\judge{\HGamma}{e_1\;op\;e_2}{\tau_{op}^\varphi}
\end{prooftree}\\
& & \\
\end{eqnarray*}

\subsection{Algorithm}
TODO: view versions:
VERSION 1:
We implemented algorithm W in Haskell. The code closely follows the specification in the book:
type and annotation variables are always given, types get unified and some constraints on annotations
are collected and solved in the end. In fact, the form of constraints is restricted to
\[\beta \sqleq \beta'\]
where $\beta$ and $\beta'$ are annotation variables.
Thus, they are quite easy to solve in a lattice like $\Annot$.

We send the Haskell files with our implementation and also show some running examples in the
next section that show the algorithm on work.

VERSION2:
Our algorithm can be found in the accompanying files and is a moderate extension
of Algorithm W for simply typed lambda calculus. Our extension generates fresh
annotation variables everywhere and constraints in the form of $\varphi \sqleq
\annot{\htau}$. After running the algorithm the types are annotated with
annotation variables, and after solving the constraints the annotation variables
get replaced by $S$ or $D$.

\subsection{Examples}

TODO: examples using Hs ; do the examples in the handout and also one that should be used in other sections. for this last one, also present a type derivation.

\section{Polyvariant Analysis}

\subsection{Types and Annotations}

Instead of considering just types, we allow for type and annotation variables and top level quatification
on these. So, we extend $\AType$ and $\Annot$ as follows:
\begin{eqnarray*}
\htau & := \ldots  \mid \alpha \\ 
\\
\varphi & := \ldots  \mid \beta \\
\end{eqnarray*}
We now consider annotated type schemes $\hsigma \in \ATypeScheme$ given by
\[\hsigma = \forall (\zeta_1 \ldots \zeta_n). \htau\]
where $\zeta_i$ are type variables or annotation variables and $\htau \in AType$.

\subsection{Type Rules: Non-Syntax Directed}

Our judgements are now of the form
\[\judge{\HGamma}{e}{\hsigma}\]
where $\hsigma$ is an annotated type scheme and $\HGamma$ also maps variables
to $\ATypeScheme$. However, we should only allow our top level
programs to have annotated types with no free variables.

We could extend our rule system with the following non-syntax directed rules that
express generalization (astraction over type and annotation variables) and
instantiation. The remaining rules would be unchanged (but considering schemes
instead of types) and the $\lbrack main \rbrack$ rule would have to allow only
for completely specified annotated types.

\begin{eqnarray*}
\lbrack gen \rbrack\;\; &
\begin{prooftree}
\judge{\HGamma}{e}{\htau}
\justifies
\judge{\HGamma}{e}{\forall (\zeta_1,\ldots, \zeta_n). \htau}
\end{prooftree}\text{if} \zeta_1, \ldots, \zeta_n \notin freeVar(\HGamma)\\
& & \\
\lbrack ins \rbrack\;\; &
\begin{prooftree}
\judge{\HGamma}{e}{\forall (\zeta_1,\ldots, \zeta_n). \htau}
\justifies
\judge{\HGamma}{e}{\theta \htau}
\end{prooftree}\text{if} dom(\theta) \subset \{\zeta_1, \ldots, \zeta_n\}\\
& & \\
\end{eqnarray*}

\subsection{Type Rules: Syntax Directed}

We will instead consider a syntax-directed version of the type rules.
The judgements will be of the form
\[\judge{\HGamma}{e}{\htau}\]
where $\htau$ are annotated types (possibly including variables).
Schemes are only allowed in the context $\HGamma$.

We introduce generalization in the $\lbrack let \rbrack$ rule and
instantiation in the $\lbrack var \rbrack$ rule. In these way, quantification
over type variables will be restricted to let bindings. The only thing
we still need to guarantee in the $\lbrack main \rbrack$ rule is that
there are no type variables in the given type.

Below, we present the rules that need to change in relation to the monovariant version.
\begin{eqnarray*}
\lbrack var \rbrack\;\; &
\begin{prooftree}
\HGamma(x)= \forall(\zeta_1,\ldots,\zeta_n). \htau
\justifies
\judge{\HGamma}{x}{\theta \htau}
\end{prooftree} \text{if} dom(\theta) \subset \{\zeta_1, \ldots, \zeta_n\}
& \\
\lbrack let \rbrack\;\; &
\begin{prooftree}
\judge{\HGamma}{e_1}{\htau_1}
\judge{\HGamma[x \mapsto \forall (\zeta_1, \ldots, \zeta_n). \htau_1]}{e_2}{\htau_2}
\justifies
\judge{\HGamma}{let x=e_1 in e_2}{\htau_2}
\end{prooftree} \text{if} \zeta_1, \ldots, \zeta_n \notin freeVar(\HGamma) \\
& & \\
\end{eqnarray*}

\subsection{Examples}


\section{Subeffecting}

\subsection{Types and Annotations}

We now define the subtyping relation. A first approach would be considering only
the toplevel annotations and say that a dynamic can also be made static.

However, this is not enough because we need some sanity checks on our types to guarantee
that we still can't end up with things like dynamic functions
that map static arguments to static results.

Shape conformant: that is, the underlying type is mantained...

\begin{eqnarray*}
int^\varphi \leq int^{\varphi'}  \text{if} \varphi \sqleq \varphi' \\
bool^\varphi \leq bool^{\varphi'}  \text{if} \varphi \sqleq \varphi' \\
\htau_1 \overset{\varphi}{\to} \htau_2 \leq \htau_1' \overset{\varphi}{\to} \htau_2' 
\text{if} \varphi \sqleq \varphi' 
 \land   \htau_1 \geq \htau_1'
 \land   \htau_2 \leq \htau_2'
 \land   wff(\htau_1 \overset{\varphi}{\to} \htau_2)
 \land   wff(\htau_1' \overset{\varphi}{\to} \htau_2')
\end{eqnarray*}

ACTUALLY WE ARE JUST GOING TO CONSIDER SUBEFFECTING

\subsection{Type Rules}

The rule for subeffecting is not syntax-directed:

\begin{eqnarray*}
\lbrack sub \rbrack\;\; &
\begin{prooftree}
\judge{\HGamma}{e}{\htau}
\justifies
\judge{\HGamma}{e}{\htau'}
\end{prooftree}\;\;\text{if}\;\; \annot{\htau} \sqleq \annot{\htau'}\\
& & \\
\end{eqnarray*}

In order to incorporate this into the syntax-directed type-rules we change the
rules $\lbrack app \rbrack$, $\lbrack if \rbrack$ and $\lbrack op \rbrack$. We are now also allowed to change $con$ to have
a static annotation, solving the constrainst will make sure this isn't a
problem.

TODO: main is definitely not correct, figure this out.
TODO: I only checked at top-level using annot, is this correct?

\begin{eqnarray*}
\lbrack con \rbrack\;\; &
\begin{prooftree}
\justifies
\judge{\HGamma}{c}{\tau_c^S}
\end{prooftree}\\
& & \\
\lbrack var\rbrack\;\; &
\begin{prooftree}
\HGamma(x)=\htau
\justifies
\judge{\HGamma}{x}{\htau}
\end{prooftree}\\
& & \\
\lbrack fn \rbrack\;\; &
\begin{prooftree}
\judge{\HGamma[x\mapsto\htau_1]}{e}{\htau_2}
\justifies
\judge{\HGamma}{fn\; x \Rightarrow e}{\htau_1 \overset{\varphi}{\to} \htau_2}
\end{prooftree}\;\; \text{if}\;\;
\varphi \sqleq \annot{\htau_1} \land \varphi \sqleq \annot{\htau_2} \\
& & \\
\lbrack fun \rbrack\;\; &
\begin{prooftree}
\judge{\HGamma[f \mapsto \htau_1 \overset{\varphi}{\to} \htau_2][x\mapsto\htau_1]}{e}{\htau_2}
\justifies
\judge{\HGamma}{fun\; x \Rightarrow e}{\htau_1 \overset{\varphi}{\to} \htau_2}
\end{prooftree}\;\; \text{if}\;\;
\varphi \sqleq \annot{\htau_1} \land \varphi \sqleq \annot{\htau_2} \\
& & \\
\lbrack app \rbrack\;\; &
\begin{prooftree}
\judge{\HGamma}{e_1}{\htau_1 \overset{\varphi}{\to} \htau_2}\; \judge{\HGamma}{e_2}{\htau_1'}
\justifies
\judge{\HGamma}{e_1 \; e_2}{\htau_2}
\end{prooftree}\;\;\text{if}\;\;
\annot{\htau_1'} \sqleq \annot{\htau}
\\
& & \\
\lbrack if \rbrack\;\; &
\begin{prooftree}
\judge{\HGamma}{e_0}{bool^{\varphi_0}}
\judge{\HGamma}{e_1}{\htau_1}
\judge{\HGamma}{e_2}{\htau_2}
\justifies
\judge{\HGamma}{if\;e_0\;then\;e_1\;else\;e_2}{\htau}
\end{prooftree}\;\;\text{if}\;\;
\varphi_0 \sqleq \annot{\htau}       \land
\annot{\htau_1} \sqleq \annot{\htau} \land
\annot{\htau_2} \sqleq \annot{\htau}
\\
& & \\
\lbrack let \rbrack\;\; &
\begin{prooftree}
\judge{\HGamma}{e_1}{\htau_1}
\judge{\HGamma[x \mapsto \htau_1]}{e_2}{\htau_2}
\justifies
\judge{\HGamma}{let\; x=e_1\; in\; e_2}{\htau_2}
\end{prooftree}\\
& & \\
\lbrack op \rbrack\;\; &
\begin{prooftree}
\judge{\HGamma}{e_1}{\tau_{op_1}^{\varphi_1}}
\judge{\HGamma}{e_2}{\tau_{op_2}^{\varphi_2}}
\justifies
\judge{\HGamma}{e_1\;op\;e_2}{\tau_{op}^\varphi}
\end{prooftree}\;\;\text{if}\;\;
\annot{\varphi_1} \sqleq \annot{\varphi} \land
\annot{\varphi_2} \sqleq \annot{\varphi}
\\
& & \\
\lbrack main \rbrack\;\; &
\begin{prooftree}
\judge{\HGamma}{e_1}{\tau^{\varphi}}
\justifies
\judge{\HGamma}{main = e_1}{\tau^\varphi}
\end{prooftree}\;\;\text{if}\;\;
D \sqleq \annot{\varphi}
\\
& & \\
\end{eqnarray*}


\subsection{Examples}

\end{document}  

