\documentclass[a4wide,12pt]{article}
\usepackage{a4wide}
\usepackage{times}
\usepackage{fancyvrb}
\usepackage{url}
\usepackage{enumerate}
\usepackage{palatino}
\usepackage{rotating}
 
\usepackage{prooftree}

\usepackage{amsmath, amsthm, amssymb}

\theoremstyle{definition}
\newtheorem{defi}{Definition}
\newtheorem{example}{Example}
\newtheorem*{conj}{Conjecture}
\newtheorem*{prob}{Problem}
\newtheorem*{question}{Question}
\theoremstyle{plain} 
\newtheorem{theo}{Theorem}
\newtheorem{prop}[theo]{Proposition}
\newtheorem{lemma}[theo]{Lemma}
\newtheorem{cor}[theo]{Corollary}
\newtheorem*{theo*}{Theorem}
\newtheorem*{prop*}{Proposition}
\newtheorem*{lemma*}{Lemma}
\newtheorem*{cor*}{Corollary}
\theoremstyle{remark}
\newtheorem*{remark}{Remark}
\newtheorem*{notation}{Notation}
\def\qed{\begin{flushright} $\Box$ \end{flushright}}

\newenvironment{prf}
                {\vspace{-2mm} \noindent {\bf Proof.}}
                {\par \nopagebreak \qed }
\newenvironment{namedprf}[1]
                {\noindent {\bf Proof (#1).}}
                {\par \nopagebreak \qed }


\def\logequiv{\Leftrightarrow}

\allowdisplaybreaks[0]
 
\def\eq{\;\; = \;\;}
\def\N{\mathbb{N}}
\def\Z{\mathbb{Z}}
 
\def\pset#1{\mathcal{P}(#1)}
\def\A#1{\mathcal{A}[\hspace{-1pt}[#1]\hspace{-1pt}]}
 
\def\const#1{\mathopen{\langle}#1\mathclose{\rangle}} % <a,b,...z>
\def\pair#1{\const{#1}}
 
\def\Stmt {\mathbf{Stmt}}
\def\Lab {\mathbf{Lab}}
\def\Blocks{\mathbf{Blocks}}
\def\Var {\mathbf{Var}}
 
 
\def\skip {\texttt{skip}\ }
\def\whilel{\texttt{while}\ }
\def\dol {\texttt{do}\ }
\def\ifl {\texttt{if}\ }
\def\thenl {\texttt{then}\ }
\def\elsel {\texttt{else}\ }
\def\printl{\texttt{print}\ }
\def\contl {\texttt{continue}\ }
\def\breakl{\texttt{break}\ }
 
\def\haskell{\textsc{Haskell}}
\def\starto{\overset{\star}{\to}}
 
\newcounter{Progenvcount}
\setcounter{Progenvcount}{0}
\newenvironment{progenv}
                {\refstepcounter{Progenvcount} \nopagebreak
                 \bigskip\hrule\nopagebreak\medskip\noindent
                 {\bf Program \arabic{Progenvcount}.} \nopagebreak\vspace{0.3cm} \nopagebreak \\ \nopagebreak
                  \nopagebreak
                 $\begin{array}{ll}}
                {\end{array}$ \bigskip\hrule\bigskip\bigskip }


%\def\programold#1{\fbox{\begin{minipage}{0.5\textwidth}\protect{$\begin{array}{ll} #1 \end{array}$}\end{minipage}}}

\def\restabR#1#2[#3]{
\begin{table}
{\scriptsize
\caption{#1}\label{#3}
\begin{center}\begin{sideways}\input{#2}\end{sideways}\end{center}
}
\end{table}}

\def\restabRtiny#1#2[#3]{
\begin{table}
{\tiny
\caption{#1}\label{#3}
\begin{center}\begin{sideways}\input{#2}\end{sideways}\end{center}
}
\end{table}}


\def\restab#1#2[#3]{
\begin{table}
\caption{#1}\label{#3}
\begin{center}\input{#2}\end{center}
\end{table}}

\def\sqleq{\sqsubseteq}

\def\htau{\hat{\tau}}
\def\HGamma{\hat{\Gamma}}
\def\judge#1#2#3{#1 \vdash #2 : #3}

\def\annot#1{\|#1\|}

\def\program#1[#2]{\begin{progenv}\label{#2}\input{#1}\end{progenv}}

\def\Tiny{\fontsize{3pt}{3pt}\selectfont}
\def\hs#1{\texttt{#1}}
 
\begin{document}
\author{Chris Eidhof, Rui S. Barbosa}
\title{Type and Effect Systems Assignment \\ Automatic Program Analysis}
 
\maketitle

\section{Monovariant Binding Time Analysis}

\subsection{Types and Annotations}
As in the book, we have the following base type system:
\[\tau := bool | int | \tau_1 \to \tau_2\]

We  now add annotations to our types. These annotations are always
one of two values |S| (for static) or |D| (for Dynamic). 
We need such an annotation
at all levels in a type (and not only in fuctions).
\begin{eqnarray*}
\htau & := bool^\varphi | int^\varphi | \htau_1 \overset{\varphi}{\to} \htau_2 
\\
\varphi & := S | D
\end{eqnarray*}

The annotations actually form a lattice where $S$ is bottom and  $D$ is top. We write $\sqleq$ for
the associated order. 

Given an annotated type $\htau$, $\annot{\htau}$ stands for its topmost annotation
and $\baset{\htau}$ stands for its underlying (not annotated) type. That is:
\begin{eqnarray*}
\annot{bool^\varphi} & = \varphi \\
\annot{int^\varphi} & = \varphi \\
\annot{\htau_1 \overset{\varphi}{\to} \htau_2} & = \varphi \\
\\
\baset{bool^\varphi} & = bool \\
\baset{int^\varphi} & = int \\
\baset{\htau_1 \overset{\varphi}{\to} \htau_2} & = \baset{\htau_1} \to \baset{\htau_2} \\
\end{eqnarray*}


Actually, some annotated types are not allowed, so we need to introduce a wellformedness
constraint to restrict those. Basically, this contraint will express that a dynamic function
has to map a dynamic argument to a dynamic result. So, it 
expects dynamic arguments and cannot produce static results. The latter is actually
impossible, whilst the former will be considered again in the other versions
(dynamic functions will be able to accept static arguments, even though they still expect dynamic arguments).
We will just be concerned to give a definition of wellformedness at top level and
induction on the type rules then guarantees we will just construct
well-formed types.
\[
wff(\htau_1 \overset{\varphi}{\to} \htau_2) 
= \varphi \sqleq \annot{\htau_1}
 \land   \varphi \sqleq \annot{\htau_2}
\]

\subsection{Type Rules}
We now present the type

\begin{eqnarray*}
\lbrack con \rbrack\;\; &
\begin{prooftree}
\justifies
\judge{\HGamma}{c}{\tau_c^\varphi}
\end{prooftree}\\
& & \\
\lbrack var\rbrack\;\; &
\begin{prooftree}
\HGamma(x)=\htau
\justifies
\judge{\HGamma}{x}{\htau}
\end{prooftree}\\
& & \\
\lbrack fn \rbrack\;\; &
\begin{prooftree}
\judge{\HGamma[x\mapsto\htau_1]}{e}{\htau_2}
\justifies
\judge{\HGamma}{fn x \Rightarrow e}{\htau_1 \overset{\varphi}{\to} \htau_2}
\end{prooftree} if
\varphi \sqleq \annot{\htau_1} \land \varphi \sqleq \annot{\htau_2} \\
& & \\
\lbrack fun \rbrack\;\; &
\begin{prooftree}
\judge{\HGamma[f \mapsto \htau_1 \overset{\varphi}{\to} \htau_2][x\mapsto\htau_1]}{e}{\htau_2}
\justifies
\judge{\HGamma}{fun x \Rightarrow e}{\htau_1 \overset{\varphi}{\to} \htau_2}
\end{prooftree} if
\varphi \sqleq \annot{\htau_1} \land \varphi \sqleq \annot{\htau_2} \\
& & \\
\lbrack app \rbrack\;\; &
\begin{prooftree}
\judge{\HGamma}{e_1}{\htau_1 \overset{\varphi}{\to} \htau_2}  \judge{\HGamma}{e_2}{\htau_1}
\justifies
\judge{\HGamma}{e_1 \; e_2}{\htau_2}
\end{prooftree}\\
& & \\
\lbrack if \rbrack\;\; &
\begin{prooftree}
\judge{\HGamma}{e_0}{bool^\varphi_0}
\judge{\HGamma}{e_1}{\htau}
\judge{\HGamma}{e_2}{\htau}
\justifies
\judge{\HGamma}{if e_0 then e_1 else e_2}{\htau}
\end{prooftree}if
\varphi_0 \sqleq \annot{\htau}\\
& & \\
\lbrack let \rbrack\;\; &
\begin{prooftree}
\judge{\HGamma}{e_1}{\htau_1}
\judge{\HGamma[x \mapsto \htau_1]}{e_2}{\htau_2}
\justifies
\judge{\HGamma}{let x=e_1 in e_2}{\htau_2}
\end{prooftree}\\
& & \\
\lbrack op \rbrack\;\; &
\begin{prooftree}
\judge{\HGamma}{e_1}{\htau_op_1^\varphi}
\judge{\HGamma[x \mapsto \htau_1]}{e_2}{\htau_op_2^\varphi}
\justifies
\judge{\HGamma}{let x=e_1 in e_2}{\htau_op^\varphi}
\end{prooftree}\\
& & \\
\end{eqnarray*}

\subsection{Algorithm}

\subsection{Examples}

\section{Polyvariant}

\subsection{Types and Annotations}

\subsection{Type Rules: Non-Syntax Directed}


\begin{eqnarray*}
\lbrack gen \rbrack\;\; &
\begin{prooftree}
\judge{\HGamma}{e}{\htau}
\justifies
\judge{\HGamma}{e}{\forall (\zeta_1,\ldots, \zeta_n). \htau}
\end{prooftree}if \zeta_1, \ldots, \zeta_n do not occur free in ???\\
& & \\
\lbrack ins \rbrack\;\; &
\begin{prooftree}
\judge{\HGamma}{e}{\forall (\zeta_1,\ldots, \zeta_n). \htau}
\justifies
\judge{\HGamma}{e}{\theta \htau}
\end{prooftree}if dom(\theta) \subset \{\zeta_1, \ldots, \zeta_n\}\\
& & \\
\end{eqnarray*}

\subsection{Type Rules: Syntax Directed}

\begin{eqnarray*}
\lbrack var \rbrack\;\; &
\begin{prooftree}
\HGamma(x)= \forall(\zeta_1,\ldots,\zeta_n). \htau
\justifies
\judge{\HGamma}{x}{\theta \htau}
\end{prooftree} if dom(\theta) \subset \{\zeta_1, \ldots, \zeta_n\}
& & \\
\lbrack let \rbrack\;\; &
\begin{prooftree}
\judge{\HGamma}{e_1}{\htau_1}
\judge{\HGamma[x \mapsto \forall (\zeta_1, \ldots, \zeta_n). \htau_1]}{e_2}{\htau_2}
\justifies
\judge{\HGamma}{let x=e_1 in e_2}{\htau_2}
\end{prooftree} if \zeta_i do not occur free in \HGamma \\
& & \\
\end{eqnarray*}

\subsection{Examples}


\section{Subeffecting}

\subsection{Types and Annotations}

We need now t define the subtyping relation.
A first approach would be considering only the toplevel annotation
and say that a dynamic can also be made static.

However, this is not enough because we need some sanity checks on our types to guarantee
that we still can't end up with things like dynamic functions
that map static arguments to static results.

Shape conformant: that is, the underlying type is mantained...

\begin{eqnarray*}
int^\varphi \leq int^{\varphi'}  if \varphi \sqleq \varphi' \\
bool^\varphi \leq bool^{\varphi'}  if \varphi \sqleq \varphi' \\
\htau_1 \overset{\varphi}{\to} \htau_2 \leq \htau_1' \overset{\varphi}{\to} \htau_2' 
if \varphi \sqleq \varphi' 
 \land   \htau_1 \geq \htau_1'
 \land   \htau_2 \leq \htau_2'
 \land   wff(\htau_1 \overset{\varphi}{\to} \htau_2)
 \land   wff(\htau_1' \overset{\varphi}{\to} \htau_2')
\end{eqnarray*}

ACTUALLY WE ARE JUST GOING TO CONSIDER SUBEFFECTING

\subsection{Type Rules: Non-Syntax Directed}

We need a new rule that ...

\begin{eqnarray*}
\lbrack sub \rbrack\;\; &
\begin{prooftree}
\judge{\HGamma}{e}{\htau}
\justifies
\judge{\HGamma}{e}{\htau'}
\end{prooftree}if \htau \leq \htau'\\
& & \\
\end{eqnarray*}

\subsection{Type Rules: Syntax Directed}

SYNTAX DIRECTED RULES : 

(TODO: write them)
\begin{eqnarray*}
\lbrack con \rbrack\;\; &
\begin{prooftree}
\justifies
\judge{\HGamma}{c}{\tau_c^\varphi}
\end{prooftree}\\
& & \\
\lbrack var\rbrack\;\; &
\begin{prooftree}
\HGamma(x)=\htau
\justifies
\judge{\HGamma}{x}{\htau}
\end{prooftree}\\
& & \\
\lbrack fn \rbrack\;\; &
\begin{prooftree}
\judge{\HGamma[x\mapsto\htau_1]}{e}{\htau_2}
\justifies
\judge{\HGamma}{fn x \Rightarrow e}{\htau_1 \overset{\varphi}{\to} \htau_2}
\end{prooftree} if
\varphi \sqleq \annot{\htau_1} \land \varphi \sqleq \annot{\htau_2} \\
& & \\
\lbrack fun \rbrack\;\; &
\begin{prooftree}
\judge{\HGamma[f \mapsto \htau_1 \overset{\varphi}{\to} \htau_2][x\mapsto\htau_1]}{e}{\htau_2}
\justifies
\judge{\HGamma}{fun x \Rightarrow e}{\htau_1 \overset{\varphi}{\to} \htau_2}
\end{prooftree} if
\varphi \sqleq \annot{\htau_1} \land \varphi \sqleq \annot{\htau_2} \\
& & \\
\lbrack app \rbrack\;\; &
\begin{prooftree}
\judge{\HGamma}{e_1}{\htau_1 \overset{\varphi}{\to} \htau_2}  \judge{\HGamma}{e_2}{\htau_1}
\justifies
\judge{\HGamma}{e_1 \; e_2}{\htau_2}
\end{prooftree}\\
& & \\
\lbrack if \rbrack\;\; &
\begin{prooftree}
\judge{\HGamma}{e_0}{bool^\varphi_0}
\judge{\HGamma}{e_1}{\htau}
\judge{\HGamma}{e_2}{\htau}
\justifies
\judge{\HGamma}{if e_0 then e_1 else e_2}{\htau}
\end{prooftree}if
\varphi_0 \sqleq \annot{\htau}\\
& & \\
\lbrack let \rbrack\;\; &
\begin{prooftree}
\judge{\HGamma}{e_1}{\htau_1}
\judge{\HGamma[x \mapsto \htau_1]}{e_2}{\htau_2}
\justifies
\judge{\HGamma}{let x=e_1 in e_2}{\htau_2}
\end{prooftree}\\
& & \\
\lbrack op \rbrack\;\; &
\begin{prooftree}
\judge{\HGamma}{e_1}{\htau_op_1^\varphi}
\judge{\HGamma[x \mapsto \htau_1]}{e_2}{\htau_op_2^\varphi}
\justifies
\judge{\HGamma}{let x=e_1 in e_2}{\htau_op^\varphi}
\end{prooftree}\\
& & \\
\end{eqnarray*}


\subsection{Examples}

\end{document}  

